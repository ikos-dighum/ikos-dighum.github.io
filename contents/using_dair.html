<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Erik Skare">

<title>R Code for Processing Big File Batches with daiR</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="using_dair_files/libs/clipboard/clipboard.min.js"></script>
<script src="using_dair_files/libs/quarto-html/quarto.js"></script>
<script src="using_dair_files/libs/quarto-html/popper.min.js"></script>
<script src="using_dair_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="using_dair_files/libs/quarto-html/anchor.min.js"></script>
<link href="using_dair_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="using_dair_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="using_dair_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="using_dair_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="using_dair_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#packages" id="toc-packages" class="nav-link active" data-scroll-target="#packages">Packages</a></li>
  <li><a href="#editing-.renviron-file-and-preparing-big-batch-processing" id="toc-editing-.renviron-file-and-preparing-big-batch-processing" class="nav-link" data-scroll-target="#editing-.renviron-file-and-preparing-big-batch-processing">Editing .Renviron file and preparing big batch processing</a></li>
  <li><a href="#processing-a-big-batch-of-.pdf-files" id="toc-processing-a-big-batch-of-.pdf-files" class="nav-link" data-scroll-target="#processing-a-big-batch-of-.pdf-files">Processing a big batch of .pdf files</a></li>
  <li><a href="#managing-unprocessed-files" id="toc-managing-unprocessed-files" class="nav-link" data-scroll-target="#managing-unprocessed-files">Managing unprocessed files</a></li>
  <li><a href="#processing-unprocessed-files" id="toc-processing-unprocessed-files" class="nav-link" data-scroll-target="#processing-unprocessed-files">Processing unprocessed files</a></li>
  <li><a href="#downloading-the-.json-files" id="toc-downloading-the-.json-files" class="nav-link" data-scroll-target="#downloading-the-.json-files">Downloading the .json files</a></li>
  <li><a href="#extracting-text-from-the-.json-files" id="toc-extracting-text-from-the-.json-files" class="nav-link" data-scroll-target="#extracting-text-from-the-.json-files">Extracting text from the .json files</a></li>
  <li><a href="#merging-the-.txt-shards" id="toc-merging-the-.txt-shards" class="nav-link" data-scroll-target="#merging-the-.txt-shards">Merging the .txt shards</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">R Code for Processing Big File Batches with daiR</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Erik Skare </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>This walk-through is intended to help you process big batches of files (whether .txt, .tiff, .jpg etc.) using using Google Document AI’s OCR service with Thomas Hegghammer’s daiR package (see: Thomas Hegghammer. <a href="https://joss.theoj.org/papers/10.21105/joss.03538">“daiR: an R package for OCR with Google Document AI.”</a> <em>The Journal of Open Software</em> 6, no. 68 (2021): 3528). Note that you need to modify some of the code depending on the files you want to process, what you have named these files, and so on.</p>
<section id="packages" class="level2">
<h2 class="anchored" data-anchor-id="packages">Packages</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(daiR)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(googleCloudStorageR)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(usethis)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(purrr)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(fs)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(glue)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(stringr)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(stringr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="editing-.renviron-file-and-preparing-big-batch-processing" class="level2">
<h2 class="anchored" data-anchor-id="editing-.renviron-file-and-preparing-big-batch-processing">Editing .Renviron file and preparing big batch processing</h2>
<p>This step assumes that you have already:</p>
<ul>
<li>Activated the Google Cloud Console</li>
<li>Linked your project to your billing account</li>
<li>Set up a service account</li>
<li>Downloaded a .json file with the service account key</li>
</ul>
<p>If you have not done so already, please confer the <a href="https://dair.info/articles/setting_up_google_storage.html">daiR website</a>.</p>
<p>Once we have completed all of the steps above, the first thing we must do is get our project ID and open our .Renviron file and provide all necessary data so that you can interact with Google Cloud Storage in R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    project_id <span class="ot">&lt;-</span> daiR<span class="sc">::</span><span class="fu">get_project_id</span>()  <span class="co"># Saves your Google Cloud project ID in the R environment</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    usethis<span class="sc">::</span><span class="fu">edit_r_environ</span>() <span class="co"># Opens the .Renviron file</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We will then save our project ID in the .Renviron file so that it looks something like this:</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    DAI_PROCESSOR_ID<span class="ot">=</span> <span class="st">"[your project ID]"</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    GCS_AUTH_FILE<span class="ot">=</span> <span class="st">"[file path to your .json file with service account key]"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then check our bucket in Google Cloud:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcs_list_buckets</span>(project_id)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first time we check our bucket in Google Cloud, the answer will be “NULL” in the R console (because there is none). We must, then, create one. We first provide the name of our bucket (in quotation marks), we then provide project ID vector (the one we saved as “project_id” in the R environment), and the choice of location for the server.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcs_create_bucket</span>(<span class="st">"[your preferred bucket name]"</span>, [your project ID], <span class="at">location =</span> <span class="st">"EU"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then save our bucket name in the .Renviron file:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>usethis<span class="sc">::</span><span class="fu">edit_r_environ</span>() <span class="co"># Open the .Renviron file in case you closed it</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># The information you stored in the .Renviron file should now look like this:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>DAI_PROCESSOR_ID<span class="ot">=</span> <span class="st">"[your project ID]"</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>GCS_DEFAULT_BUCKET<span class="ot">=</span> <span class="st">"[your bucket name]"</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>GCS_AUTH_FILE<span class="ot">=</span> <span class="st">"[complete file path to the your service account key (.json file)]"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If our bucket name has not been saved in our .Renviron file, then we have to provide bucket name with the following function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcs_global_bucket</span>(<span class="st">"[bucket name]"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then check the content of the bucket we have created (which obviously will be “NULL” as we have not uploaded any files yet)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcs_list_objects</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="processing-a-big-batch-of-.pdf-files" class="level2">
<h2 class="anchored" data-anchor-id="processing-a-big-batch-of-.pdf-files">Processing a big batch of .pdf files</h2>
<p>Here, I am assuming that you have already uploaded all the files you want to process to the Google Cloud bucket and that everything is ready to be processed.</p>
<p>As Hegghammer writes:</p>
<blockquote class="blockquote">
<p><em>Although dai_async() takes batches of files, it is constrained by Google’s rate limits. Currently, a dai_async() call can contain maximum 50 files (a multi-page pdf counts as one file), and you can not have more than 5 batch requests and 10 000 pages undergoing processing at any one time. Therefore, if you’re looking to process a large batch, you need to spread the dai_async() calls out over time. The simplest solution is to make a function that sends files off individually with a small wait in between. Say we have a vector called big_batch containing thousands of filenames.First we would make a function like this:</em></p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>process_slowly <span class="ot">&lt;-</span> <span class="cf">function</span>(file) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dai_async</span>(file)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Sys.sleep</span>(<span class="dv">15</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then create an object with all the content in our bucket:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>content <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>big_batch <span class="ot">&lt;-</span> content<span class="sc">$</span>name</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We should at this point have a “process_slowly” (our function) and a “big_batch” (our files uploaded to the bucket) in the R environment. What remains is processing these files with the map() function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(big_batch, process_slowly)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="managing-unprocessed-files" class="level2">
<h2 class="anchored" data-anchor-id="managing-unprocessed-files">Managing unprocessed files</h2>
<p>Every now and then, you will receive the following message: “HTTP status: 429 - unsuccesful if processing hundreds of files” for some of the files you have tried to process. So we need to identify those files that we were unable to process. First, we will create an object will all .json files in our bucket (the processed .pdf files are turned into .json files) and mine their stems:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>contents <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>jsons <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"*.json"</span>, contents<span class="sc">$</span>name, <span class="at">value =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then use the head() and tail() functions to make sure we have all .json files:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(jsons)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(jsons)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then use regex to identify the stems of the .json files in our bucket as they have a prefix with “100143430000013434530000” or similar. P.S. The name of your .json file and the regex code required depend on the name of the .pdf files you uploaded. The regex code below is based on file names based on dates - for example “2018_08_31”, “2011_10_01” etc. The “d” stands for “digit” and {2} and {4} is the number of digits. For example, “d{4}”” are the four digits in year (“2018”, for example) while “d{2}”” are the two digits in months and days (“08”, for example). So “\d{4}<em>\d{2}</em>\d{2}” refers to “\[YEAR]<em>\[MONTH]</em>\[DAY]”. A regex cheat sheet helps if you find this confusing: https://www.rexegg.com/regex-quickstart.html</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>json_stems <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_extract_all</span>(jsons, <span class="st">"</span><span class="sc">\\</span><span class="st">d{4}_</span><span class="sc">\\</span><span class="st">d{2}_</span><span class="sc">\\</span><span class="st">d{2}"</span>)) </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(json_stems)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then try to identify the unique .json stems:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>json_stems_unique <span class="ot">&lt;-</span> <span class="fu">unique</span>(json_stems)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(json_stems_unique)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once we have identified the unique .json stems, we will need to do the same with the files we uploaded. In this case, we uploaded .pdfs, but you can change this to .jpg or .tiff if that are the files you uploaded. We will use the same regex code to find the stems:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>pdfs <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"*.pdf"</span>, contents<span class="sc">$</span>name, <span class="at">value =</span> <span class="cn">TRUE</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>pdfs <span class="ot">&lt;-</span> <span class="fu">list.files</span>(dir)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>pdf_stems <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">str_extract_all</span>(pdfs, <span class="st">"</span><span class="sc">\\</span><span class="st">d{4}_</span><span class="sc">\\</span><span class="st">d{2}_</span><span class="sc">\\</span><span class="st">d{2}"</span>))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>pdf_stems_unique <span class="ot">&lt;-</span> <span class="fu">unique</span>(pdf_stems)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then use the setdiff() function to compare the unique .json files and the unique .pdf files (the object “remaining” will contain the file name of all the unprocessed .pdf files in the bucket):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>remaining <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(pdf_stems_unique, json_stems_unique)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="processing-unprocessed-files" class="level2">
<h2 class="anchored" data-anchor-id="processing-unprocessed-files">Processing unprocessed files</h2>
<p>Still, if we try to run the map() function on the vector “remaining” (the same function we used for the object “big_batch” above) it won’t execute as there is no information in the object containing the file names that we are trying to reprocess .pdfs. The names in the object are simply “2018_02_31” (but we need “2018_02_31.pdf”). We thus need the paste0() function to add a “.pdf” to the end of the file names:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>remaining <span class="ot">&lt;-</span> <span class="fu">paste0</span>(remaining, <span class="st">".pdf"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then, once this is done, process the unprocessed .pdf files:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(remaining, process_slowly)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="downloading-the-.json-files" class="level2">
<h2 class="anchored" data-anchor-id="downloading-the-.json-files">Downloading the .json files</h2>
<p>Once we have processed all the .pdf files (or .tiff/.jpg), we have all the .json files we need (the output from the preceding processing). The following function assumes that you want to download all the .json files but not the .pdf files you processed (in my case, I processed 30,000 .pdf files which created an output of more than 100,000 .json files. It would necessarily be a laborious task to download all those files manually). The grep() function makes sure we only download the .json files and not the .pdfs we uploaded. The saveToDisk makes sure to download the files to your working directory.</p>
<p>If you log into Google Storage and check the content of your bucket, you will see that all .json files have been saved in different folders (one folder per .pdf files with 1-5 .json file depending on the length of your .pdf file). So you need the str_replace_all() function to replace the / in the directory paths to a “_” so that R can find the .json files in your bucket:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>bucket_contents <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>only_jsons <span class="ot">&lt;-</span> <span class="fu">grep</span>(<span class="st">"*.json"</span>, bucket_contents<span class="sc">$</span>name, <span class="at">value =</span> <span class="cn">TRUE</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(only_jsons, <span class="sc">~</span> <span class="fu">gcs_get_object</span>(.x, <span class="at">saveToDisk =</span> <span class="fu">str_replace_all</span>(.x, <span class="st">"/"</span>, <span class="st">"_"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once you have the .json files, you can delete all content in the bucket:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>contents <span class="ot">&lt;-</span> <span class="fu">gcs_list_objects</span>()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(contents<span class="sc">$</span>name, gcs_delete_object)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="extracting-text-from-the-.json-files" class="level2">
<h2 class="anchored" data-anchor-id="extracting-text-from-the-.json-files">Extracting text from the .json files</h2>
<p>Once we have downloaded all our .json files, we need to extract the text data. We will first provide a path to the directory containing all our .json files, and then provide a destination directory where we want to save the extracted shards:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>jsons_on_file <span class="ot">&lt;-</span> <span class="fu">dir_ls</span>(<span class="fu">here</span>(<span class="st">"[directory with .json files]"</span>))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>jsons <span class="ot">&lt;-</span> <span class="fu">dir_ls</span>(<span class="fu">here</span>(<span class="st">"[directory with .json files]"</span>))</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>destdir <span class="ot">&lt;-</span> <span class="fu">here</span>(<span class="st">"[directory where we want to save the .txt files output]"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will then extract the text from the .json files by writing the following function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> jsons_on_file</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>get_text_and_name <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">glue</span>(<span class="st">"Parsing {basename(x)} .."</span>))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  text <span class="ot">&lt;-</span> <span class="fu">text_from_dai_file</span>(x)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  stem <span class="ot">&lt;-</span> <span class="fu">str_sub</span>(<span class="fu">basename</span>(x), <span class="at">end =</span> <span class="sc">-</span><span class="dv">5</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  filename <span class="ot">&lt;-</span> <span class="fu">paste0</span>(stem, <span class="st">"txt"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  filepath <span class="ot">&lt;-</span> <span class="fu">file.path</span>(destdir, filename)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Sys.setlocale</span>(<span class="st">"LC_CTYPE"</span>, <span class="st">"arabic"</span>)<span class="co"># Sets the locale to Arabic should you process Arabic text files (can be changed to Germany, Korean etc.). Only relevant for Windows users.</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">write.csv</span>(text, filepath, <span class="at">fileEncoding =</span> <span class="st">"utf8"</span>, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Sys.setlocale</span>(<span class="st">"LC_CTYPE"</span>, <span class="st">"English"</span>)<span class="co"># Resets the locale back to English.</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(jsons, get_text_and_name)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="merging-the-.txt-shards" class="level2">
<h2 class="anchored" data-anchor-id="merging-the-.txt-shards">Merging the .txt shards</h2>
<p>Once you have extracted all .txt shards, you have to merge them (so that the .pdf file “2018_08_15.pdf” is turned into “2018_08_15.txt” and not “2018_08_15_01.txt”, “2018_08_15_02.txt”, “2018_08_15_03.txt” etc.). To do so, we will need to install the GitHub version of daiR:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">"hegghammer/daiR"</span>, <span class="at">force =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We then provide the directory where we saved our .txt file shards and the directory in which we want to place the merged .txt files:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>shard_dir <span class="ot">&lt;-</span> <span class="fu">here</span>(<span class="st">"[directory with all .txt shards]"</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>dest_dir <span class="ot">&lt;-</span> <span class="fu">here</span>(<span class="st">"[directory where we want to save the merged .txt files]"</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">merge_shards</span>(shard_dir, dest_dir) <span class="co"># The function to merge the shards.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>